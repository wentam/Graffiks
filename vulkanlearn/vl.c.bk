#include <vulkan/vulkan.h>
#include <vulkan/vulkan_core.h>
#include <X11/X.h>    
#include <X11/Xlib.h> 
#include <vulkan/vulkan_xlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_vulkan.h>
#include <unistd.h>
#include <SDL2/SDL_syswm.h>
#include <graffiks/graffiks.h>
#include <graffiks/internal.h>

VkInstance vk_instance;
VkPhysicalDevice physical_device;
VkDevice device;
VkQueue graphics_queue;
VkQueue present_queue;
VkSurfaceKHR vk_surface;
VkImage *swap_chain_images;
VkSwapchainKHR swap_chain;
VkFormat swap_chain_image_format;
VkExtent2D swap_chain_extent;

typedef struct {
  uint32_t *data;
  int  *file_size;
} SlurpedFile;

SlurpedFile* slurpFile(char *filename) {
    FILE *f = fopen(filename, "rb");
    if (f == NULL) {
      printf("Error opening file\n");
    }
    
    // get file size
    fseek(f, 0L, SEEK_END);
    int file_size = ftell(f);
    fseek(f, 0L, SEEK_SET);

    uint32_t *output = malloc(file_size);
    fread(output, sizeof(uint32_t), file_size/sizeof(uint32_t), f);

    int *out_file_size = malloc(sizeof(int));
    *out_file_size = file_size;

    SlurpedFile *out = malloc(sizeof(SlurpedFile));
    out->data = output;
    out->file_size = out_file_size;

    return out;
}

void spitSlurpedFile(SlurpedFile *sf) {
  free(sf->data);
  free(sf->file_size);
  free(sf);
}

void god_function() {
  // create SDL window
  if (SDL_Init(SDL_INIT_VIDEO)) {
    printf("Failed to initialize SDL: %s\n",SDL_GetError());
  }

  SDL_Window *window = SDL_CreateWindow(
      "VulkanTriangleTest", 0, 0, 1024, 768,
      SDL_WINDOW_VULKAN);


  // get SDL wm info
  SDL_SysWMinfo wmInfo;                                          
  SDL_VERSION(&wmInfo.version);                                  
  if (SDL_GetWindowWMInfo(window, &wmInfo) == SDL_FALSE) {       
    printf("Failed to get window info: %s\n",SDL_GetError());    
  }                                                              

  // ask SDL what vulkan extensions it wants for this window
 /* unsigned int sdl_vulkan_extension_count = 0;
  if (SDL_Vulkan_GetInstanceExtensions(window, &sdl_vulkan_extension_count, NULL) != SDL_TRUE){
    printf("Failed to get vulkan extensions from SDL\n");
    exit(0);
  }*/

  //printf("SDL wants %i extensions\n",sdl_vulkan_extension_count);

  // create an array of extensions we want to enable
  //int extensions_we_want_count = 0;
 // int extension_count = sdl_vulkan_extension_count+extensions_we_want_count;
 // const char *extension_names[extension_count];

  //if(SDL_Vulkan_GetInstanceExtensions(window, &sdl_vulkan_extension_count,extension_names) != SDL_TRUE) {
   // printf("Failed to get vulkan extensions from SDL\n");
    //exit(0);
 // }

  //extension_names[sdl_vulkan_extension_count] = "VK_KHR_swapchain";

  /*
  for (int i = 0; i < extension_count; i++)  {
    printf("Enabling instance extension %s\n",extension_names[i]);
  }
  */

  // set up vulkan validation layers
  const char *validation_layers[1] = {"VK_LAYER_KHRONOS_validation"};

  //uint32_t validation_layer_count;
  //vkEnumerateInstanceLayerProperties(&validation_layer_count, NULL);

  //VkLayerPropertios available_layers[validation_layer_count];
  //vkEnumerateInstanceLayerProperties(&validation_layer_count, available_layers);

  gfks_window_system window_systems = GFKS_WINDOW_SYSTEM_X11_BITFLAG;
  gfks_context *gfks_context = gfks_create_context(&window_systems);
  
  vk_instance = *(gfks_context->vk_instance);

  /*
  // create vulkan instance
  VkApplicationInfo app_info = {};
  app_info.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
  app_info.pApplicationName = "Teeeeest!!!";
  app_info.applicationVersion = VK_MAKE_VERSION(1,0,0);  
  app_info.pEngineName = "notgraffiks";
  app_info.engineVersion = VK_MAKE_VERSION(1,0,0);
  app_info.apiVersion = VK_API_VERSION_1_1;

  VkInstanceCreateInfo create_info = {};
  create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
  create_info.pApplicationInfo = &app_info;
  create_info.pNext = NULL;
  create_info.flags = 0;
  create_info.enabledLayerCount = 0;
  //create_info.ppEnabledLayerNames = validation_layers;
  create_info.enabledExtensionCount = sdl_vulkan_extension_count;
  create_info.ppEnabledExtensionNames = extension_names;

  VkResult r = vkCreateInstance(&create_info, NULL, &vk_instance);
  if (r != VK_SUCCESS) {
    printf("failed to create vulkan instance %i\n",r); 
    exit(0);
  }

  */

  // create our surface
  VkXlibSurfaceCreateInfoKHR xlib_surface_create_info = {};
  xlib_surface_create_info.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
  xlib_surface_create_info.pNext = NULL;
  xlib_surface_create_info.flags = 0;
  xlib_surface_create_info.dpy = wmInfo.info.x11.display;
  xlib_surface_create_info.window = wmInfo.info.x11.window;

  if(vkCreateXlibSurfaceKHR(vk_instance, &xlib_surface_create_info, NULL, &vk_surface) != VK_SUCCESS) {
    printf("Failed to create Xlib surface!\n"); 
  }
  
  // get physical device
  uint32_t physical_device_count = 0;
  if (vkEnumeratePhysicalDevices(vk_instance, &physical_device_count, NULL) != VK_SUCCESS) {
    printf("Error enumerating physical devices\n");
    exit(0);
  }

  if (physical_device_count <= 0) {
    printf("No vulkan compatible devices found\n");
    exit(0);
  }

  printf("Found %i vulkan device(s)\n", physical_device_count);

  VkPhysicalDevice physical_devices[physical_device_count];
  if (vkEnumeratePhysicalDevices(vk_instance, &physical_device_count, physical_devices) != VK_SUCCESS) {
    printf("Error enumerating physical devices\n");
    exit(0);
  }

  for (int i = 0; i < physical_device_count; i++) {
    VkPhysicalDeviceProperties devprops; 
    vkGetPhysicalDeviceProperties(physical_devices[i],&devprops);
    printf("  Device %i is %s\n",i,devprops.deviceName);
  }

  printf("  Statically using device 0 for this test\n");
  physical_device = physical_devices[0];

  // decide what queue family we want to use to draw our triangle
  int chosen_queue_family;
  
  uint32_t queue_family_count = 0;
  vkGetPhysicalDeviceQueueFamilyProperties(physical_device, &queue_family_count, NULL);

  printf("Found %i queue families\n", queue_family_count);

  VkQueueFamilyProperties queue_families[queue_family_count];
  vkGetPhysicalDeviceQueueFamilyProperties(physical_device, &queue_family_count, queue_families);

  for (int i = 0; i < queue_family_count; i++) {
      printf("  Queue family %i has count %i and flags 0x%08x\n",i,queue_families[i].queueCount, queue_families[i].queueFlags);
  }

  printf("  Statically using queue family 0 for this test\n");
  chosen_queue_family = 0;

  // create array of device extensions we want enabled
  int device_extension_count = 1;
  const char *device_extension_names[device_extension_count];
  device_extension_names[0] = "VK_KHR_swapchain";

  for (int i = 0; i < device_extension_count; i++) {
    printf("Enabling device extension %s\n", device_extension_names[i]);
  }

  // set up graphics queue creation info
  VkDeviceQueueCreateInfo graphics_queue_create_info = {};
  graphics_queue_create_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
  graphics_queue_create_info.queueFamilyIndex = 0; 
  graphics_queue_create_info.queueCount = 1;

  float queuePriority = 1.0f;
  graphics_queue_create_info.pQueuePriorities = &queuePriority;

  // set up present queue creation info
  VkDeviceQueueCreateInfo present_queue_create_info = {};
  present_queue_create_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
  present_queue_create_info.queueFamilyIndex = 0; 
  present_queue_create_info.queueCount = 1;

  //float queuePriority = 1.0f;
  present_queue_create_info.pQueuePriorities = &queuePriority;

  // set up logical device   
  VkPhysicalDeviceFeatures device_features = {};

  VkDeviceQueueCreateInfo queue_create_infos[] = {graphics_queue_create_info, present_queue_create_info};

  VkDeviceCreateInfo device_create_info = {};
  device_create_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
  device_create_info.pQueueCreateInfos = queue_create_infos;
  device_create_info.queueCreateInfoCount = 2;
  device_create_info.pEnabledFeatures = &device_features;
  device_create_info.enabledExtensionCount = device_extension_count;
  device_create_info.ppEnabledExtensionNames = device_extension_names;
  device_create_info.enabledLayerCount = 0;

  if (vkCreateDevice(physical_device, &device_create_info, NULL, &device) != VK_SUCCESS) {
    printf("Failed to create logical device\n");
    exit(0);
  }

  // get our graphics queue
  vkGetDeviceQueue(device, chosen_queue_family,0,&graphics_queue);
  vkGetDeviceQueue(device, 0,0,&present_queue);

  VkBool32 presentSupport = False;
  vkGetPhysicalDeviceSurfaceSupportKHR(physical_device, 0, vk_surface, &presentSupport);
  printf("Queue family 0 present support: %i\n",presentSupport);

  // look at surface capabilities, decide swap extent size
  VkSurfaceCapabilitiesKHR capabilities; 
  if (vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physical_device, vk_surface, &capabilities) != VK_SUCCESS) {
    printf("Error getting surface capabilities\n");
    exit(0);
  }

  printf("Our surface capabilities:\n");
  printf("  minimum image count:%i\n",capabilities.minImageCount);
  printf("  maximum image count:%i\n",capabilities.maxImageCount);
  printf("  current extent width:%i\n",capabilities.currentExtent.width);
  printf("  current extent height:%i\n",capabilities.currentExtent.height);
  printf("  minimum extent width:%i\n",capabilities.minImageExtent.width);
  printf("  minimum extent height:%i\n",capabilities.minImageExtent.height);
  printf("  maximum extent width:%i\n",capabilities.maxImageExtent.width);
  printf("  maximum extent height:%i\n",capabilities.maxImageExtent.height);

  printf("  Statically using a 1024x768 swap extent\n");
  printf("  Statically using 2 swap chain images\n");

  swap_chain_extent.width = 1024;
  swap_chain_extent.height = 768;
  int target_swap_chain_image_count = 2;


  // pick out a surface format
  int chosen_format_index;

  uint32_t format_count;
  if (vkGetPhysicalDeviceSurfaceFormatsKHR(physical_device, vk_surface, &format_count, NULL) != VK_SUCCESS) {
    printf("Error getting device surface formats\n");
    exit(0);
  }

  printf("Got %i device surface formats\n",format_count);

  VkSurfaceFormatKHR formats[format_count];
  if (vkGetPhysicalDeviceSurfaceFormatsKHR(physical_device, vk_surface, &format_count, formats) != VK_SUCCESS) {
    printf("Error getting device surface formats\n");
    exit(0);
  }

  for (int i = 0; i < format_count; i++) {
    VkSurfaceFormatKHR f = formats[i];
    printf("  Surface format %i has VkFormat enum value %i\n",i, f.format);
    printf("  Surface format %i has VkColorSpaceKHR enum value %i\n",i, f.colorSpace);
    
  }

  printf("  Statically using surface format 0 for this test\n");
  chosen_format_index = 0;
  swap_chain_image_format = formats[chosen_format_index].format;

  // choose a device surface present mode
  int chosen_present_mode;
 
  uint32_t present_mode_count; 
  if (vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, vk_surface, &present_mode_count, NULL) != VK_SUCCESS) {
    printf("Error getting device surface present modes\n");
    exit(0);
  }

  printf("Got %i device surface present modes\n",present_mode_count);

  VkPresentModeKHR present_modes[present_mode_count];
  if (vkGetPhysicalDeviceSurfacePresentModesKHR(physical_device, vk_surface, &present_mode_count, present_modes) != VK_SUCCESS){
    printf("Error getting device surface present modes\n");
    exit(0);
  }

  for (int i = 0; i < present_mode_count; i++) {
    printf("  present mode %i has VkPresentModeKHR enum value %i\n",i,present_modes[i]);
  }

  printf("  Statically using present mode 0 for this test\n");
  chosen_present_mode = 0;

  // create swap chain
  VkSwapchainCreateInfoKHR swap_chain_create_info = {};
  swap_chain_create_info.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
  swap_chain_create_info.surface = vk_surface;
  swap_chain_create_info.minImageCount = target_swap_chain_image_count;
  swap_chain_create_info.imageFormat = formats[chosen_format_index].format;
  swap_chain_create_info.imageColorSpace =formats[chosen_format_index].colorSpace;
  swap_chain_create_info.imageExtent = swap_chain_extent;
  swap_chain_create_info.imageArrayLayers = 1;
  swap_chain_create_info.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
  swap_chain_create_info.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
  swap_chain_create_info.queueFamilyIndexCount = 0;
  swap_chain_create_info.pQueueFamilyIndices = NULL;
  swap_chain_create_info.preTransform = capabilities.currentTransform;
  swap_chain_create_info.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
  swap_chain_create_info.presentMode = present_modes[chosen_present_mode];
  swap_chain_create_info.clipped = VK_TRUE;
  swap_chain_create_info.oldSwapchain = VK_NULL_HANDLE;


  if (vkCreateSwapchainKHR(device, &swap_chain_create_info, NULL, &swap_chain) != VK_SUCCESS) {
    printf("Failed to create swap chain\n"); 
    exit(0);
  }   

  // get swap chain images
  uint32_t swap_chain_image_count;
  if (vkGetSwapchainImagesKHR(device, swap_chain, &swap_chain_image_count, NULL) != VK_SUCCESS) {
    printf("Error getting swapchain images\n");
    exit(0);
  }

  printf("Got %i images from swap chain\n",swap_chain_image_count);

  swap_chain_images = malloc(sizeof(VkImage)*swap_chain_image_count);
  if (vkGetSwapchainImagesKHR(device, swap_chain, &swap_chain_image_count, swap_chain_images) != VK_SUCCESS) {
    printf("Error getting swapchain images\n");
    exit(0);
  }
 
 // create swap chain image views 
 VkImageView swap_chain_image_views[swap_chain_image_count];
 
 for (int i = 0; i < swap_chain_image_count; i++) {
   VkImageViewCreateInfo ci = {};
   ci.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
   ci.image = swap_chain_images[i];
   ci.viewType = VK_IMAGE_VIEW_TYPE_2D;
   ci.format = swap_chain_image_format;
   ci.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;
   ci.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;
   ci.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;
   ci.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;
   ci.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
   ci.subresourceRange.baseMipLevel = 0;
   ci.subresourceRange.levelCount = 1;
   ci.subresourceRange.baseArrayLayer = 0;
   ci.subresourceRange.layerCount = 1;

   if (vkCreateImageView(device, &ci, NULL, &swap_chain_image_views[i]) != VK_SUCCESS) {
     printf("Error creating image view %i\n");
     exit(0);
   }
 }

 // create shader modules
 SlurpedFile* vertshader = slurpFile("vert.spv"); 
 SlurpedFile* fragshader = slurpFile("frag.spv"); 

 printf("Shader file sizes must be a multiple of 4:\n");
 printf("  Vertex shader filesize is %i\n",*(vertshader->file_size));
 printf("  Fragment shader filesize is %i\n",*(fragshader->file_size));

 /*
 printf("vertex shader data SPIR-V:\n");
 for (int i = 0; i < *(vertshader->file_size); i++) {
   printf("%c",vertshader->data[i]);
 }
 printf("\n");
*/

 /*
 printf("fragment shader data SPIR-V:\n");
 for (int i = 0; i < *(fragshader->file_size); i++) {
   printf("%c",fragshader->data[i]);
 }
 printf("\n");
*/

 VkShaderModule vert_shader_module;
 VkShaderModuleCreateInfo vert_shader_module_create_info = {};
 vert_shader_module_create_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
 vert_shader_module_create_info.codeSize = *(vertshader->file_size);
 vert_shader_module_create_info.pCode = vertshader->data;

 VkShaderModule frag_shader_module;
 VkShaderModuleCreateInfo frag_shader_module_create_info = {};
 frag_shader_module_create_info.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
 frag_shader_module_create_info.codeSize = *(fragshader->file_size);
 frag_shader_module_create_info.pCode = fragshader->data;

 if (vkCreateShaderModule(device, &vert_shader_module_create_info, NULL, &vert_shader_module) != VK_SUCCESS) {
    printf("Failed to create vertex shader module\n");
    exit(0);
 }

 int rr = vkCreateShaderModule(device, &frag_shader_module_create_info, NULL, &frag_shader_module) ; 
 if (rr != VK_SUCCESS) {
    printf("Failed to create fragment shader module: %i\n",rr);
    printf("VK_ERROR_INVALID_SHADER_NV would be: %i\n",VK_ERROR_INVALID_SHADER_NV);
    printf("VK_ERROR_OUT_OF_HOST_MEMORY would be: %i\n",VK_ERROR_OUT_OF_HOST_MEMORY);
    printf("VK_ERROR_OUT_OF_DEVICE_MEMORY would be: %i\n",VK_ERROR_OUT_OF_DEVICE_MEMORY);
    exit(0);
 }

 // set up shader stage creation info
 VkPipelineShaderStageCreateInfo vertex_shader_stage_create_info = {};
 vertex_shader_stage_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;  
 vertex_shader_stage_create_info.stage = VK_SHADER_STAGE_VERTEX_BIT; 
 vertex_shader_stage_create_info.module = vert_shader_module; 
 vertex_shader_stage_create_info.pName = "main";

 VkPipelineShaderStageCreateInfo fragment_shader_stage_create_info = {};
 fragment_shader_stage_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;  
 fragment_shader_stage_create_info.stage = VK_SHADER_STAGE_FRAGMENT_BIT; 
 fragment_shader_stage_create_info.module = frag_shader_module; 
 fragment_shader_stage_create_info.pName = "main";

 VkPipelineShaderStageCreateInfo shader_stages[] = {vertex_shader_stage_create_info, fragment_shader_stage_create_info};

 // set up input info
 VkPipelineVertexInputStateCreateInfo vertex_input_state_create_info = {};
 vertex_input_state_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; 
 vertex_input_state_create_info.vertexBindingDescriptionCount = 0; 
 vertex_input_state_create_info.pVertexBindingDescriptions = NULL; 
 vertex_input_state_create_info.vertexAttributeDescriptionCount = 0; 
 vertex_input_state_create_info.pVertexAttributeDescriptions = NULL;
 
 VkPipelineInputAssemblyStateCreateInfo input_assembly_state_create_info = {};
 input_assembly_state_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
 input_assembly_state_create_info.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
 input_assembly_state_create_info.primitiveRestartEnable = VK_FALSE;

 // set up viewport info
 VkViewport viewport = {};
 viewport.x = 0.0f;
 viewport.y = 0.0f;
 viewport.width = (float) swap_chain_extent.width;
 viewport.height = (float) swap_chain_extent.height;
 viewport.minDepth = 0.0f;
 viewport.maxDepth = 1.0f;

 VkRect2D scissor = {};
 scissor.offset = (VkOffset2D){0, 0};
 scissor.extent = swap_chain_extent;

 VkPipelineViewportStateCreateInfo view_port_state_create_info = {};
 view_port_state_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
 view_port_state_create_info.viewportCount = 1;
 view_port_state_create_info.pViewports = &viewport;
 view_port_state_create_info.scissorCount = 1;
 view_port_state_create_info.pScissors = &scissor;

 // define rasterizer create info
 VkPipelineRasterizationStateCreateInfo rasterizer = {};
 rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
 rasterizer.depthClampEnable = VK_FALSE;
 rasterizer.rasterizerDiscardEnable = VK_FALSE;
 rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
 rasterizer.lineWidth = 1.0F;
 rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
 rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
 rasterizer.depthBiasEnable = VK_FALSE;
 rasterizer.depthBiasConstantFactor = 0.0f;
 rasterizer.depthBiasClamp = 0.0f;
 rasterizer.depthBiasSlopeFactor = 0.0f;

 // define multisampling info
 // (we won't bother with multisampling for this test)
 VkPipelineMultisampleStateCreateInfo multisampling = {};
 multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;
 multisampling.sampleShadingEnable = VK_FALSE;
 multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
 multisampling.minSampleShading = 1.0f;
 multisampling.pSampleMask = NULL;
 multisampling.alphaToCoverageEnable = VK_FALSE;
 multisampling.alphaToOneEnable = VK_FALSE;

 // set up color blending info
 VkPipelineColorBlendAttachmentState color_blend_attachment = {};
 color_blend_attachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;
 color_blend_attachment.blendEnable = VK_FALSE;

 VkPipelineColorBlendStateCreateInfo color_blending = {};
 color_blending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;
 color_blending.logicOpEnable = VK_FALSE;
 color_blending.attachmentCount = 1;
 color_blending.pAttachments = &color_blend_attachment;

 // set up pipeline layout 
 VkPipelineLayout pipeline_layout;
 VkPipelineLayoutCreateInfo pipeline_layout_create_info = {};
 pipeline_layout_create_info.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;

 if (vkCreatePipelineLayout(device, &pipeline_layout_create_info, NULL, &pipeline_layout) != VK_SUCCESS) {
  printf("Failed to create pipeline layout\n");
 }

  // subpass dependancies
  VkSubpassDependency dep = {};
  dep.srcSubpass = VK_SUBPASS_EXTERNAL;
  dep.dstSubpass = 0;
  dep.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
  dep.srcAccessMask = 0;
  dep.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;
  dep.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;


  // define render pass
  VkAttachmentDescription color_attachment = {};
  color_attachment.format = swap_chain_image_format;
  color_attachment.samples = VK_SAMPLE_COUNT_1_BIT;
  color_attachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;
  color_attachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;
  color_attachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;
  color_attachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;
  color_attachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;
  color_attachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;

  VkAttachmentReference color_attachment_ref = {};
  color_attachment_ref.attachment = 0;
  color_attachment_ref.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;

  VkSubpassDescription subpass = {};
  subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;
  subpass.colorAttachmentCount = 1;
  subpass.pColorAttachments = &color_attachment_ref;

  VkRenderPass render_pass;

  VkRenderPassCreateInfo render_pass_create_info = {};
  render_pass_create_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;
  render_pass_create_info.attachmentCount = 1;
  render_pass_create_info.pAttachments = &color_attachment;
  render_pass_create_info.subpassCount = 1;
  render_pass_create_info.pSubpasses = &subpass;
  render_pass_create_info.dependencyCount = 1;
  render_pass_create_info.pDependencies = &dep;

  if (vkCreateRenderPass(device, &render_pass_create_info, NULL, &render_pass) != VK_SUCCESS) {
    printf("Error creating render pass\n");
    exit(0);
  }

  // create pipeline
  VkGraphicsPipelineCreateInfo pipeline_create_info = {}; 
  pipeline_create_info.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
  pipeline_create_info.stageCount = 2;
  pipeline_create_info.pStages = shader_stages;
  pipeline_create_info.pVertexInputState = &vertex_input_state_create_info;
  pipeline_create_info.pInputAssemblyState = &input_assembly_state_create_info;
  pipeline_create_info.pViewportState = &view_port_state_create_info;
  pipeline_create_info.pRasterizationState = &rasterizer;
  pipeline_create_info.pMultisampleState = &multisampling;
  pipeline_create_info.pDepthStencilState = NULL;
  pipeline_create_info.pColorBlendState = &color_blending;
  pipeline_create_info.pDynamicState = NULL;
  pipeline_create_info.layout = pipeline_layout;
  pipeline_create_info.renderPass = render_pass;
  pipeline_create_info.subpass = 0;
  pipeline_create_info.basePipelineHandle = VK_NULL_HANDLE;
  pipeline_create_info.basePipelineIndex = -1;

  VkPipeline graphics_pipeline;

  if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipeline_create_info, NULL, &graphics_pipeline) != VK_SUCCESS) {
    printf("Failed to create graphics pipeline\n");
    exit(0);
  }


  // create a framebuffer for each swapchain image view
  VkFramebuffer swap_chain_frame_buffers[swap_chain_image_count];

  for (int i = 0; i < swap_chain_image_count; i++) {
    VkImageView attachments[] = {swap_chain_image_views[i]};

    VkFramebufferCreateInfo frame_buffer_create_info = {};
    frame_buffer_create_info.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;
    frame_buffer_create_info.renderPass = render_pass;
    frame_buffer_create_info.attachmentCount =1;
    frame_buffer_create_info.pAttachments  = attachments;
    frame_buffer_create_info.width = swap_chain_extent.width;
    frame_buffer_create_info.height = swap_chain_extent.height;
    frame_buffer_create_info.layers = 1;

    if (vkCreateFramebuffer(device, &frame_buffer_create_info, NULL, &swap_chain_frame_buffers[i]) != VK_SUCCESS) {
      printf("Failed to create framebuffer for swap buffer image %i\n", i);
      exit(0);
    }
  }

  // create command pool
  VkCommandPool command_pool;
  
  VkCommandPoolCreateInfo pool_create_info = {};
  pool_create_info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
  pool_create_info.queueFamilyIndex = chosen_queue_family;
  pool_create_info.flags = 0;
  
  if (vkCreateCommandPool(device, &pool_create_info, NULL, &command_pool) != VK_SUCCESS) {
    printf("Failed to create command pool\n");
    exit(0);
  }

  // create command buffer for each swap chain image
  VkCommandBuffer command_buffers[swap_chain_image_count];
  
  VkCommandBufferAllocateInfo alloc_info = {};
  alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
  alloc_info.commandPool = command_pool;
  alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
  alloc_info.commandBufferCount = (uint32_t) swap_chain_image_count;

  if (vkAllocateCommandBuffers(device, &alloc_info, command_buffers) != VK_SUCCESS) {
    printf("Failed to create command buffers\n"); 
  }

  // set each command buffer to complete a basic render pass
  for (int i = 0; i < swap_chain_image_count; i++)  {
    VkCommandBufferBeginInfo begin_info = {};
    begin_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
    begin_info.flags = 0;
    begin_info.pInheritanceInfo = NULL;

    if (vkBeginCommandBuffer(command_buffers[i], &begin_info) != VK_SUCCESS) {
      printf("Failed to begin command buffer %i\n",i);
    }

    VkRenderPassBeginInfo render_pass_begin_info = {}; 
    render_pass_begin_info.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
    render_pass_begin_info.renderPass = render_pass;
    render_pass_begin_info.framebuffer = swap_chain_frame_buffers[i];
    render_pass_begin_info.renderArea.offset = (VkOffset2D){0, 0};
    render_pass_begin_info.renderArea.extent = swap_chain_extent;

    VkClearValue clearColor = {0.0f,0.0f,0.0f,1.0f};
    render_pass_begin_info.clearValueCount = 1;
    render_pass_begin_info.pClearValues = &clearColor;

    vkCmdBeginRenderPass(command_buffers[i], &render_pass_begin_info, VK_SUBPASS_CONTENTS_INLINE);
    vkCmdBindPipeline(command_buffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics_pipeline);
    vkCmdDraw(command_buffers[i],3,1,0,0);
    vkCmdEndRenderPass(command_buffers[i]);
    if (vkEndCommandBuffer(command_buffers[i]) != VK_SUCCESS) {
      printf("Failed to end command buffer\n");
      exit(0);
    }
  }

  // create semaphores
  VkSemaphore image_available_semaphore;    
  VkSemaphore render_finished_semaphore;

  VkSemaphoreCreateInfo semaphore_create_info = {};
  semaphore_create_info.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;

  if (vkCreateSemaphore(device, &semaphore_create_info, NULL, &image_available_semaphore) != VK_SUCCESS) {
    printf("Failed to create semaphore\n");
    exit(0);
  }

  if (vkCreateSemaphore(device, &semaphore_create_info, NULL, &render_finished_semaphore) != VK_SUCCESS) {
    printf("Failed to create semaphore\n");
    exit(0);
  }

  // ------------------
  // --- draw frame ---
  // ------------------

  //for (int i = 0; i < 5; i++) {

  // get next image
  uint32_t image_index; 
  int vr = vkAcquireNextImageKHR(device, swap_chain, UINT64_MAX, image_available_semaphore, VK_NULL_HANDLE, &image_index);

  printf("got result %i from vkAquireNextImageKHR (0 is success)\n",vr);
  printf("got image %i from vkAquireNextImageKHR\n",image_index);

  // submit the command buffer 
  VkSemaphore wait_semaphores[] = {image_available_semaphore};
  VkPipelineStageFlags wait_stages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
  VkSemaphore signal_semaphores[] = {render_finished_semaphore};


  VkSubmitInfo submit_info = {};
  submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
  submit_info.waitSemaphoreCount = 1;
  submit_info.pWaitSemaphores = wait_semaphores;
  submit_info.pWaitDstStageMask = wait_stages;
  submit_info.commandBufferCount = 1;
  submit_info.pCommandBuffers = &command_buffers[image_index];
  submit_info.signalSemaphoreCount = 1;
  submit_info.pSignalSemaphores = signal_semaphores;

  if (vkQueueSubmit(graphics_queue, 1, &submit_info, VK_NULL_HANDLE) != VK_SUCCESS) {
    printf("Failed to submit command buffer to queue\n");
    exit(0);
  } 

  // presentation
  VkSwapchainKHR swap_chains[] = {swap_chain};

  VkPresentInfoKHR present_info = {}; 
  present_info.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
  present_info.waitSemaphoreCount = 1;
  present_info.pWaitSemaphores = signal_semaphores;
  present_info.swapchainCount = 1;
  present_info.pSwapchains = swap_chains;
  present_info.pImageIndices = &image_index;
  present_info.pResults = NULL;
  
  if (vkQueuePresentKHR(present_queue, &present_info)!= VK_SUCCESS) {
    printf("Failed to present image\n");
  }
  //}
}


void done(){
  vkDestroyInstance(vk_instance, NULL);
  free(swap_chain_images);
}

void main() {
  god_function();
  sleep(10);
  done();
}
